<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2025-11-17 Mon 10:19 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simulation</title>
<meta name="author" content="Matthew Elwin" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="./../pubme.css" type="text/css"/>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../index.html"> UP </a>
 |
 <a accesskey="H" href="./../index.html"> HOME </a>
</div><div id="content" class="content">
<header>
<h1 class="title">Simulation</h1>
</header><nav id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#overview-1-P-10">Overview</a></li>
<li><a href="#advantages-of-simulation-1-P-1">Advantages of Simulation</a></li>
<li><a href="#disadvantages-of-simulation-1-P-1">Disadvantages of Simulation</a></li>
<li><a href="#choosing-a-simulator-1-P-1">Choosing a simulator</a>
<ul>
<li><a href="#why-is-simulation-needed--2-P-1">Why is simulation needed?</a></li>
<li><a href="#identifying-what-must-be-modeled-2-P-1">Identifying What Must Be Modeled</a></li>
<li><a href="#differences-between-simulation-engines-2-P-1">Differences Between Simulation Engines</a></li>
<li><a href="#custom-simulators-2-P-1">Custom Simulators</a></li>
</ul>
</li>
<li><a href="#gazebo-1-P-1">Gazebo</a>
<ul>
<li><a href="#gazebo-features-2-P-1">Gazebo Features</a></li>
</ul>
</li>
<li><a href="#other-simulators-1-P-1">Other Simulators</a>
<ul>
<li><a href="#open-source-simulators-2-P-1">Open Source Simulators</a>
<ul>
<li><a href="#current-simulators-3-P-1">Current Simulators</a></li>
<li><a href="#less-maintained-3-P-1">Less Maintained</a></li>
</ul>
</li>
<li><a href="#closed-source-simulators-2-P-1">Closed Source Simulators</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<div id="outline-container-overview-1-P-10" class="outline-2">
<h2 id="overview-1-P-10">Overview</h2>
<div class="outline-text-2" id="text-org6d7d92b">
<p>
Computer simulations represent the physical world as a set of state variables
and perform computations to advance this state forward (or backward) in time.
</p>

<p>
In robotics, simulation is used to perform robotic experiments without
requiring robotic hardware. Instead, a mathematical model of the robot
and its environment is used to approximate the behavior of a real robot.
</p>
</div>
</div>

<div id="outline-container-advantages-of-simulation-1-P-1" class="outline-2">
<h2 id="advantages-of-simulation-1-P-1">Advantages of Simulation</h2>
<div class="outline-text-2" id="text-orga15622f">
<ul class="org-ul">
<li>You control all variables and can replay identical scenarios</li>
<li>You can inspect and set the full state of the system accurately</li>
<li>You can easily change properties of the robot, sensors, and the environment</li>
<li>The robot does not break or run out of battery power</li>
</ul>
</div>
</div>
<div id="outline-container-disadvantages-of-simulation-1-P-1" class="outline-2">
<h2 id="disadvantages-of-simulation-1-P-1">Disadvantages of Simulation</h2>
<div class="outline-text-2" id="text-org07bda82">
<ul class="org-ul">
<li>Behavior differs from the real world</li>
<li>Only effects that are already modeled and known can be examined</li>
<li>Even if an effect is modeled, numerical error can become an issue</li>
<li>Simulated robots can't vacuum your floor</li>
</ul>
</div>
</div>

<div id="outline-container-choosing-a-simulator-1-P-1" class="outline-2">
<h2 id="choosing-a-simulator-1-P-1">Choosing a simulator</h2>
<div class="outline-text-2" id="text-choosing-a-simulator-1-P-1">
</div>
<div id="outline-container-why-is-simulation-needed--2-P-1" class="outline-3">
<h3 id="why-is-simulation-needed--2-P-1">Why is simulation needed?</h3>
<div class="outline-text-3" id="text-orgd6f6d45">
<p>
The purpose of your simulation is a major factor in choosing a simulator:
</p>

<p>
Here are a few examples:
</p>
<ul class="org-ul">
<li>Run ROS code without the robot present:
<ul class="org-ul">
<li>The actual physics may not matter very much</li>
<li>The speed of the simulation may not matter much</li>
<li>The point is just to run code and see some movement</li>
<li>ROS integration is very important</li>
</ul></li>
<li>Train machine learning models:
<ul class="org-ul">
<li>Here trade-offs between speed and accuracy must be weighed</li>
<li>What simulator is chosen depends on the method</li>
<li>ROS integration may be un-important: the implementation of the algorithm
(particularly the part that connects the policy to robot actions) may not
need to be the same between simulation and the real robot</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-identifying-what-must-be-modeled-2-P-1" class="outline-3">
<h3 id="identifying-what-must-be-modeled-2-P-1">Identifying What Must Be Modeled</h3>
<div class="outline-text-3" id="text-org017e9c9">
<p>
The needs of your robotic application dictate the complexity of your
model and the requirements for your simulation engine.
Choosing the correct level of simulated detail is an important design choice:
the more detail, the more accuracy, but also the more computation time and complexity.
</p>

<p>
Here are some types of simulations used in robotics:
</p>
<ul class="org-ul">
<li>Discrete Position
<ul class="org-ul">
<li>Robots are agents that can move from grid-space to grid-space</li>
<li>The mechanics of the movement are ignored</li>
</ul></li>
<li>Kinematic
<ul class="org-ul">
<li>Control positions and velocities of the joints</li>
</ul></li>
<li>Dynamic
<ul class="org-ul">
<li>Robots and objects have inertia and you control forces and torques</li>
<li>Newton's Laws or Euler Lagrange can be used</li>
<li>Complexity of the dynamic effects modeled can vary widely</li>
</ul></li>
<li>Finite Element
<ul class="org-ul">
<li>Parts of the robot can deform according to stress-strain relations</li>
</ul></li>
<li>Fluid Dynamics
<ul class="org-ul">
<li>For underwater or aerial robots</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-differences-between-simulation-engines-2-P-1" class="outline-3">
<h3 id="differences-between-simulation-engines-2-P-1">Differences Between Simulation Engines</h3>
<div class="outline-text-3" id="text-org84a4db3">
<ol class="org-ol">
<li>What integration scheme do they use?
<ul class="org-ul">
<li>Most simulations ultimately hinge on integrating differential equations</li>
<li>Many simulators provide a choice or parameters that can be tuned</li>
<li>Accuracy vs speed trade-offs</li>
<li>Specific types of differential equations may be better suited to different integration schemes</li>
</ul></li>
<li>What phenomenon can be modeled?
<ul class="org-ul">
<li>Collisions?</li>
<li>Friction?</li>
<li>Lighting conditions?</li>
<li>Aerodynamics?</li>
</ul></li>
<li>Visualization tools?
<ul class="org-ul">
<li>Can you view the simulated objects?</li>
<li>Can you generate plots based on the simulation?</li>
<li>How do you provide input?</li>
<li>How do you read the output?</li>
</ul></li>
<li>What robots are supported?
<ul class="org-ul">
<li>Specific to certain types of robots?</li>
<li>General purpose, can make nearly anything?</li>
<li>Are their pre-built models available?</li>
</ul></li>
</ol>
</div>
</div>
<div id="outline-container-custom-simulators-2-P-1" class="outline-3">
<h3 id="custom-simulators-2-P-1">Custom Simulators</h3>
<div class="outline-text-3" id="text-org97243e4">
<ul class="org-ul">
<li>Sometimes, you have a simple model for your robot</li>
<li>Using a simple model, you can usually write your own simulator</li>
<li>In some cases, writing your own can be simpler than invoking a complicated
general purpose simulator like gazebo.</li>
<li>Writing a simulation for a robot is a good way to verify you understand the system</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-gazebo-1-P-1" class="outline-2">
<h2 id="gazebo-1-P-1">Gazebo</h2>
<div class="outline-text-2" id="text-orgc40b3d9">
<ul class="org-ul">
<li><a href="https://gazebosim.org">Gazebo</a> (Formerly called Ignition Gazebo) is the latest simulator developed by Open Robotics</li>
<li>This is the simulator with the best ROS 2 integration, because it is developed under the same umbrella organization as ROS</li>
<li>It is a good simulator for testing ROS code: that is it is easy to use the same ROS nodes to control a real robot and a robot simulated in Gazebo.</li>
<li><a href="./gazebo.html">Notes on using Gazebo</a></li>
</ul>
</div>

<div id="outline-container-gazebo-features-2-P-1" class="outline-3">
<h3 id="gazebo-features-2-P-1">Gazebo Features</h3>
<div class="outline-text-3" id="text-orgc10d05d">
<ul class="org-ul">
<li>Choice of physics engines:
<ul class="org-ul">
<li>By default it uses the <a href="https://dartsim.github.io/">Dart</a> physics engine</li>
</ul></li>

<li>Graphics:  Gazebo provides a graphical interface for viewing and creating
simulated worlds.
<ul class="org-ul">
<li>Think of the Gazebo display as being a stand-in for the real world and the RViz display is a visualization based off of what
the robot senses.</li>
<li>Gazebo has powerful rendering features that are aimed at creating photo-realistic models so that computer vision in the simulator can be useful</li>
</ul></li>

<li>Plugin Architecture: Everything in Gazebo is written as a C++ plugin.
<ul class="org-ul">
<li>This makes Gazebo extendable, and provides you with the ability
to not only add new objects in Gazebo but also new physical phenomena</li>
<li>Gazebo comes with many plugins, representing, for example, different types of sensors</li>
<li>ROS support for Gazebo is provided by a plugin</li>
</ul></li>

<li>Network: Like ROS, gazebo consists of multiple processes that communicate with each
other using.  There are counterparts to ROS mesages and services,but these are entirely different systems</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-other-simulators-1-P-1" class="outline-2">
<h2 id="other-simulators-1-P-1">Other Simulators</h2>
<div class="outline-text-2" id="text-org49a46c5">
<p>
Here is a list of other robotics simulators. You may encounter them, and some are quite popular, particularly for machine learning
</p>
</div>
<div id="outline-container-open-source-simulators-2-P-1" class="outline-3">
<h3 id="open-source-simulators-2-P-1">Open Source Simulators</h3>
<div class="outline-text-3" id="text-open-source-simulators-2-P-1">
</div>
<div id="outline-container-current-simulators-3-P-1" class="outline-4">
<h4 id="current-simulators-3-P-1">Current Simulators</h4>
<div class="outline-text-4" id="text-org12e0d6c">
<ul class="org-ul">
<li><a href="http://www.mujoco.org/">MuJoCo</a> - A dynamics simulator specifically built for robotics tasks. This is likely one of the more state-of-the-art simulators.
<ul class="org-ul">
<li>Purchased by DeepMind, which has made it open-source (formerly was very expensive and proprietary).</li>
</ul></li>
<li><a href="https://drake.mit.edu">Drake</a> C++ Simulation tools for dynamic robots, using optimization techniques.
<ul class="org-ul">
<li>Started at MIT, now backed by Toyota Research.</li>
<li>High-fidelity simulation (particularly for contacts), at the expense of simulation speed.</li>
<li>User has visibility into all algorithms and principles used in computation of the simulation</li>
</ul></li>
<li><a href="https://projectchrono.org">Project Chrono</a> - A multi-physics simulation.
<ul class="org-ul">
<li>Does finite elements, granular material, real physics that takes a long time to compute.</li>
<li>Only recommended if you have a specific need for high-fidelity physics</li>
</ul></li>
<li><a href="https://cyberbotics.com">Webbots</a> - Robot simulator with a long history. Just released a new version in 2023</li>
</ul>
</div>
</div>
<div id="outline-container-less-maintained-3-P-1" class="outline-4">
<h4 id="less-maintained-3-P-1">Less Maintained</h4>
<div class="outline-text-4" id="text-org4db51fb">
<ul class="org-ul">
<li><a href="https://pybullet.org">pybullet</a> - A pythons simulator based on Bullet.
<ul class="org-ul">
<li>Formerly popular in the reinforcement-learning community, still some residual use.</li>
<li>Ever since MuJoCo became open-source, it's popularity has waned.</li>
</ul></li>
<li><a href="http://nxr.northwestern.edu/trep">trep</a> - Developed in Todd Murphey's lab. Good numerical
algorithms and transparency in how the dynamics are actually solved. Does not support contact/friction.</li>
<li><p>
The <a href="http://classic.gazebosim.org">Gazebo Classic</a> (or the simulator formerly known as Gazebo) is the main simulator for ROS 1
</p>
<ul class="org-ul">
<li>Like ROS, it is maintained by the Open Source Robotics Foundation, but it is a standalone program</li>
<li>Many concepts in Gazebo are similar to ROS but slightly different</li>
<li>We will focus on how to use Gazebo from ROS</li>
<li>Carefully designed ROS programs can seamlessly switch between controlling</li>
</ul>
<p>
a Gazebo simulation and a real robot.
</p></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-closed-source-simulators-2-P-1" class="outline-3">
<h3 id="closed-source-simulators-2-P-1">Closed Source Simulators</h3>
<div class="outline-text-3" id="text-org455c28e">
<ul class="org-ul">
<li><a href="https://www.coppeliarobotics.com">CoppeliaSim</a> (formerly V-Rep)
<ul class="org-ul">
<li>Free for educational use, but not open source.</li>
</ul></li>
<li><a href="https://developer.nvidia.com/isaac/sim">Isaac Sim</a>
<ul class="org-ul">
<li>Popular due to its speed (for RL training) and good rendering (can learn from objects rendered in simulation and transfer to real world).</li>
<li>Ubuntu 24.04 and ROS 2 Jazzy are not yet supported (as of 10/2024).</li>
<li>Technically, Isaac Sim is Open-Source, but it is built on top of NVIDIA Omniverse, which is not</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p><p class="outline-2">Author: Matthew Elwin. </p></p>
</div>
</body>
</html>
